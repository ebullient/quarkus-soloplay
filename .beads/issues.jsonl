{"id":"quarkus-soloplay-qsu","title":"WebSocket streaming play + server-side memory","description":"## Goal\nReplace stateless `/api/story/play` request/response with a WebSocket-based streaming “Play” experience with server-side persisted conversation memory and history.\n\n## Current State\n- Backend: `PlayAgent` + `GameMasterService` invoked via `POST /api/story/play` (`dev.ebullient.soloplay.api.StoryResource#play`)\n- Frontend: `src/main/resources/META-INF/resources/play-interface.js` uses `fetch()` and stores history in `localStorage`\n- Memory: ephemeral (no persisted `ChatMemoryStore`)\n\n## Target State\n- WebSocket endpoint: `/ws/story/{storyThreadId}` streams tokens/events\n- Server-side conversation continuity via persisted `ChatMemoryStore` (Neo4j)\n- Server-side transcript/history so UI does not depend on `localStorage`\n- Memory compaction/eviction hook creates durable story artifacts (e.g., `StoryEvent` summaries)\n\n## Key Decisions\n- Memory key: `storyThreadId` (same as current `@MemoryId String storyThreadId`)\n- Streaming: LangChain4j `TokenStream` for partial deltas + final completion\n- Rendering: stream text; final message replaces placeholder with server-rendered HTML (CommonMark via `MarkdownAugmenter`)\n\n## Milestones\n1) WS protocol + endpoint skeleton\n2) `PlayAgent.chatStream(...)` + streaming orchestration service\n3) Persisted `ChatMemoryStore` in Neo4j (+ config)\n4) Transcript persistence + history_request\n5) Compaction hook -\u003e `StoryEvent` creation\n6) Switch play UI to WebSocket + reconnect/history\n\n## Risks / Notes\n- Concurrency: enforce 1 in-flight generation per WS connection; decide multi-tab behavior for same story thread.\n- Consider adding `io.quarkiverse.langchain4j:quarkus-langchain4j-websockets-next` later if we want WS-connection-based default memory IDs; not required if we keep `@MemoryId storyThreadId`.\nEOF`\n","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-09T14:46:37.592207-05:00","created_by":"elh","updated_at":"2026-01-09T15:00:53.062208-05:00"}
{"id":"quarkus-soloplay-qsu.1","title":"WS protocol + StoryPlayWebSocket skeleton","design":"## Goal\nCreate `/ws/story/{storyThreadId}` WebSocket endpoint for Play with a stable JSON protocol for streaming.\n\n## Protocol\nClient -\u003e Server (JSON):\n- `{\"type\":\"history_request\",\"limit\":100}`\n- `{\"type\":\"user_message\",\"id\":\"\u003cuuid\u003e\",\"text\":\"...\"}`\n- (optional) `{\"type\":\"cancel\",\"id\":\"\u003cuuid\u003e\"}`\n\nServer -\u003e Client (JSON):\n- `{\"type\":\"session\",\"storyThreadId\":\"...\",\"storyName\":\"...\"}`\n- `{\"type\":\"history\",\"messages\":[{\"role\":\"user|assistant\",\"markdown\":\"...\",\"html\":\"...\",\"ts\":\"...\"}]}`\n- `{\"type\":\"assistant_start\",\"id\":\"\u003cuuid\u003e\"}`\n- `{\"type\":\"assistant_delta\",\"id\":\"\u003cuuid\u003e\",\"text\":\"...\"}`\n- `{\"type\":\"assistant_done\",\"id\":\"\u003cuuid\u003e\",\"markdown\":\"...\",\"html\":\"...\"}`\n- `{\"type\":\"error\",\"id\":\"\u003cuuid\u003e\",\"message\":\"...\"}`\n\n## Acceptance\n- Connection open sends `session` (or `error` if story thread missing)\n- Sending `user_message` yields `assistant_start` + one or more `assistant_delta` + `assistant_done`\n- Endpoint enforces 1 in-flight generation per connection (reject or queue)\n\n## Implementation Notes\n- New endpoint: `src/main/java/dev/ebullient/soloplay/api/StoryPlayWebSocket.java`\n- Message models: `src/main/java/dev/ebullient/soloplay/api/ws/PlayWsClientMessage.java`, `.../PlayWsServerMessage.java`\n","acceptance_criteria":"Client can connect to /ws/story/{id}; server sends session; user_message returns assistant_start/delta/done messages","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:46:55.752517-05:00","created_by":"elh","updated_at":"2026-01-09T15:02:24.933979-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.1","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:46:55.755475-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.2","title":"Add PlayAgent TokenStream method","description":"## Goal\nAdd streaming API to `PlayAgent` using LangChain4j `TokenStream`, while keeping current non-streaming method for REST fallback.\n\n## Acceptance\n- `PlayAgent` exposes `TokenStream chatStream(...)` mirroring the existing parameter set (including `@MemoryId storyThreadId` and `@UserMessage`)\n- Existing `String chat(...)` remains unchanged and continues to back `POST /api/story/play`\n- Streaming emits partial deltas and final completion\n\n## Notes\n- Uses LangChain4j `dev.langchain4j.service.TokenStream`\n- Provider must support streaming (Ollama typically does; validate behavior with configured model)\n","design":"File: PlayAgent.java","acceptance_criteria":"PlayAgent exposes chatStream(...) returning TokenStream; existing chat(...) remains for REST fallback","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:47:06.358302-05:00","created_by":"elh","updated_at":"2026-01-09T15:02:52.879196-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.2","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:47:06.361185-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.3","title":"GameMasterStreamingService orchestration","description":"## Goal\nAdd a streaming orchestration service that loads story context and streams agent output to the WebSocket client.\n\n## Responsibilities\n- Load `StoryThread` (same logic as current `GameMasterService.chat`)\n- Call `PlayAgent.chatStream(...)`\n- Wire `TokenStream` callbacks:\n  - onPartialResponse -\u003e send `assistant_delta`\n  - onCompleteResponse -\u003e render markdown -\u003e HTML via `MarkdownAugmenter`, send `assistant_done`\n  - onError -\u003e send `error`\n- Update `StoryThread.lastPlayedAt` on successful completion\n\n## Acceptance\n- WS responses include HTML in `assistant_done` and deltas in `assistant_delta`\n- `lastPlayedAt` updates once per completed assistant response\n- Errors don’t kill the WS connection (unless unrecoverable)\n\n## Files\n- `src/main/java/dev/ebullient/soloplay/ai/GameMasterStreamingService.java` (new)","design":"Files: GameMasterStreamingService.java, reuse MarkdownAugmenter","acceptance_criteria":"Loads StoryThread; streams deltas to WS; updates lastPlayedAt on completion; handles errors","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:47:44.132219-05:00","created_by":"elh","updated_at":"2026-01-09T15:03:12.087177-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.3","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:47:44.135333-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.4","title":"Transcript persistence + history_request","design":"Files: ConversationMessage.java + repository changes","acceptance_criteria":"Server can send last N turns from Neo4j transcript; UI no longer depends on localStorage","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:47:59.450372-05:00","created_by":"elh","updated_at":"2026-01-09T14:47:59.450372-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.4","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:47:59.453238-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.5","title":"WebSocket play-interface.js (streaming UI)","design":"Files: META-INF/resources/play-interface.js, templates/Story/play.html","acceptance_criteria":"UI streams assistant tokens; final message renders HTML from server; reconnect re-requests history","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:48:08.150006-05:00","created_by":"elh","updated_at":"2026-01-09T14:48:08.150006-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.5","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:48:08.153223-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.6","title":"Memory compaction hook -\u003e StoryEvent creation","design":"Files: ChatMemoryCompactedEvent.java, ChatMemoryCompactionListener.java","acceptance_criteria":"When memory window drops messages, a StoryEvent is created (tags: memory/summary)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:48:14.453611-05:00","created_by":"elh","updated_at":"2026-01-09T14:48:14.453611-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.6","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:48:14.456637-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.7","title":"Neo4jChatMemoryStore (persist LangChain4j memory)","description":"## Goal\nPersist LangChain4j chat memory to Neo4j so conversations survive restarts.\n\n## Approach\nImplement `dev.langchain4j.store.memory.chat.ChatMemoryStore`:\n- Key: `storyThreadId`\n- Value: serialized message list (LangChain4j serializer/deserializer)\n\n## Acceptance\n- Memory persists across app restart for the same `storyThreadId`\n- Window size controlled via `quarkus.langchain4j.chat-memory.*` config\n\n## Data\n- Neo4j node like `(:ChatMemory {id, messagesJson, updatedAt})`\n","design":"Files: Neo4jChatMemoryStore.java; config in application.properties","acceptance_criteria":"ChatMemoryStore reads/writes messages keyed by storyThreadId; survives restart","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:57:39.607478-05:00","created_by":"elh","updated_at":"2026-01-09T14:58:03.945964-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.7","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:57:39.608181-05:00","created_by":"elh"}]}
