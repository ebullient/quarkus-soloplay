{"id":"quarkus-soloplay-qsu","title":"WebSocket streaming play + server-side memory","description":"## Goal\nReplace stateless `/api/story/play` request/response with a WebSocket-based streaming “Play” experience with server-side persisted conversation memory and history.\n\n## Current State\n- Backend: `PlayAgent` + `GameMasterService` invoked via `POST /api/story/play` (`StoryResource.play`)\n- Frontend: `src/main/resources/META-INF/resources/play-interface.js` uses `fetch()` and stores history in `localStorage`\n- Memory: ephemeral (no `ChatMemoryStore` persistence)\n\n## Target State\n- WebSocket endpoint: `/ws/story/{storyThreadId}` streams tokens and events\n- Server-side conversation continuity via persisted `ChatMemoryStore` (Neo4j)\n- Server-side transcript/history endpoint (WS `history_request` or REST) so UI does not depend on `localStorage`\n- Memory compaction/eviction hook creates durable story artifacts (e.g., `StoryEvent` summary)\n\n## Key Decisions\n- Memory key: `storyThreadId` (shared across reconnects; consistent with current `@MemoryId String storyThreadId`)\n- Streaming: LangChain4j `TokenStream` (partial deltas + final completion)\n- UI rendering: stream as plain text; final replace with server-rendered HTML (CommonMark via `MarkdownAugmenter`)\n\n## Milestones\n1) Streaming agent method + WS endpoint skeleton\n2) Neo4j `ChatMemoryStore` wired in + config\n3) Transcript persistence + history load (no localStorage)\n4) Compaction hook -\u003e `StoryEvent` creation\n5) Switch play UI to WebSocket + reconnect behavior\n\n## Notes / Risks\n- Consider adding `io.quarkiverse.langchain4j:quarkus-langchain4j-websockets-next` if we want WS-connection-based default memory ids later.\n- Concurrency: enforce 1 in-flight generation per WS connection; decide behavior for multiple tabs on same story.\n","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-09T14:46:37.592207-05:00","created_by":"elh","updated_at":"2026-01-09T14:55:09.489368-05:00"}
{"id":"quarkus-soloplay-qsu.1","title":"WS protocol + StoryPlayWebSocket skeleton","design":"Files: StoryPlayWebSocket.java, PlayWs*Message.java","acceptance_criteria":"Client can connect to /ws/story/{id}; server sends session; user_message returns assistant_start/delta/done messages","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:46:55.752517-05:00","created_by":"elh","updated_at":"2026-01-09T14:46:55.752517-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.1","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:46:55.755475-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.2","title":"Add PlayAgent TokenStream method","design":"File: PlayAgent.java","acceptance_criteria":"PlayAgent exposes chatStream(...) returning TokenStream; existing chat(...) remains for REST fallback","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:47:06.358302-05:00","created_by":"elh","updated_at":"2026-01-09T14:47:06.358302-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.2","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:47:06.361185-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.3","title":"GameMasterStreamingService orchestration","design":"Files: GameMasterStreamingService.java, reuse MarkdownAugmenter","acceptance_criteria":"Loads StoryThread; streams deltas to WS; updates lastPlayedAt on completion; handles errors","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:47:44.132219-05:00","created_by":"elh","updated_at":"2026-01-09T14:47:44.132219-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.3","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:47:44.135333-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.4","title":"Transcript persistence + history_request","design":"Files: ConversationMessage.java + repository changes","acceptance_criteria":"Server can send last N turns from Neo4j transcript; UI no longer depends on localStorage","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:47:59.450372-05:00","created_by":"elh","updated_at":"2026-01-09T14:47:59.450372-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.4","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:47:59.453238-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.5","title":"WebSocket play-interface.js (streaming UI)","design":"Files: META-INF/resources/play-interface.js, templates/Story/play.html","acceptance_criteria":"UI streams assistant tokens; final message renders HTML from server; reconnect re-requests history","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:48:08.150006-05:00","created_by":"elh","updated_at":"2026-01-09T14:48:08.150006-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.5","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:48:08.153223-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.6","title":"Memory compaction hook -\u003e StoryEvent creation","design":"Files: ChatMemoryCompactedEvent.java, ChatMemoryCompactionListener.java","acceptance_criteria":"When memory window drops messages, a StoryEvent is created (tags: memory/summary)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:48:14.453611-05:00","created_by":"elh","updated_at":"2026-01-09T14:48:14.453611-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.6","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:48:14.456637-05:00","created_by":"elh"}]}
