{"id":"quarkus-soloplay-qsu","title":"WebSocket streaming play + server-side memory","description":"## Goal\nReplace stateless `/api/story/play` request/response with a WebSocket-based streaming “Play” experience with server-side persisted conversation memory and history.\n\n## Current State\n- Backend: `PlayAgent` + `GameMasterService` invoked via `POST /api/story/play` (`dev.ebullient.soloplay.api.StoryResource#play`)\n- Frontend: `src/main/resources/META-INF/resources/play-interface.js` uses `fetch()` and stores history in `localStorage`\n- Memory: ephemeral (no persisted `ChatMemoryStore`)\n\n## Target State\n- WebSocket endpoint: `/ws/story/{storyThreadId}` streams tokens/events\n- Server-side conversation continuity via persisted `ChatMemoryStore` (Neo4j)\n- Server-side transcript/history so UI does not depend on `localStorage`\n- Memory compaction/eviction hook creates durable story artifacts (e.g., `StoryEvent` summaries)\n\n## Key Decisions\n- Memory key: `storyThreadId` (same as current `@MemoryId String storyThreadId`)\n- Streaming: LangChain4j `TokenStream` for partial deltas + final completion\n- Rendering: stream text; final message replaces placeholder with server-rendered HTML (CommonMark via `MarkdownAugmenter`)\n\n## Milestones\n1) WS protocol + endpoint skeleton\n2) `PlayAgent.chatStream(...)` + streaming orchestration service\n3) Persisted `ChatMemoryStore` in Neo4j (+ config)\n4) Transcript persistence + history_request\n5) Compaction hook -\u003e `StoryEvent` creation\n6) Switch play UI to WebSocket + reconnect/history\n\n## Risks / Notes\n- Concurrency: enforce 1 in-flight generation per WS connection; decide multi-tab behavior for same story thread.\n- Consider adding `io.quarkiverse.langchain4j:quarkus-langchain4j-websockets-next` later if we want WS-connection-based default memory IDs; not required if we keep `@MemoryId storyThreadId`.\nEOF`\n","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-09T14:46:37.592207-05:00","created_by":"elh","updated_at":"2026-01-09T15:00:53.062208-05:00"}
{"id":"quarkus-soloplay-qsu.1","title":"WS protocol + StoryPlayWebSocket skeleton","design":"## Goal\nCreate `/ws/story/{storyThreadId}` WebSocket endpoint for Play with a stable JSON protocol.\n\n## Protocol\nClient-\u003eServer:\n- `history_request {limit}`\n- `user_message {id,text}`\nServer-\u003eClient:\n- `session {storyThreadId,storyName}`\n- `assistant_start {id}`\n- `assistant_delta {id,text}`\n- `assistant_done {id,markdown,html}`\n- `error {id,message}`\n\n## Acceptance\n- Connect sends `session`\n- Sending `user_message` results in `assistant_start` + ≥1 `assistant_delta` + `assistant_done`\n- Errors are returned as `error` without killing the server\n\n## Files\n- `src/main/java/dev/ebullient/soloplay/api/StoryPlayWebSocket.java`\n- `src/main/java/dev/ebullient/soloplay/api/ws/PlayWsClientMessage.java`\n- `src/main/java/dev/ebullient/soloplay/api/ws/PlayWsServerMessage.java`\n","acceptance_criteria":"Client can connect to /ws/story/{id}; server sends session; user_message returns assistant_start/delta/done messages","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:46:55.752517-05:00","created_by":"elh","updated_at":"2026-01-09T14:56:11.920131-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.1","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:46:55.755475-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.2","title":"Add PlayAgent TokenStream method","description":"## Goal\nAdd streaming to `PlayAgent` using LangChain4j `TokenStream` while keeping the current non-streaming method for REST fallback.\n\n## Acceptance\n- `PlayAgent` exposes `TokenStream chatStream(...)`\n- Existing `String chat(...)` remains unchanged\n- Stream produces partial deltas and a final completion\n\n## Notes\n- Verify Ollama provider supports streaming for the configured model.\n","design":"File: PlayAgent.java","acceptance_criteria":"PlayAgent exposes chatStream(...) returning TokenStream; existing chat(...) remains for REST fallback","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:47:06.358302-05:00","created_by":"elh","updated_at":"2026-01-09T14:56:39.947942-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.2","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:47:06.361185-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.3","title":"GameMasterStreamingService orchestration","design":"Files: GameMasterStreamingService.java, reuse MarkdownAugmenter","acceptance_criteria":"Loads StoryThread; streams deltas to WS; updates lastPlayedAt on completion; handles errors","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:47:44.132219-05:00","created_by":"elh","updated_at":"2026-01-09T14:47:44.132219-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.3","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:47:44.135333-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.4","title":"Transcript persistence + history_request","design":"Files: ConversationMessage.java + repository changes","acceptance_criteria":"Server can send last N turns from Neo4j transcript; UI no longer depends on localStorage","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:47:59.450372-05:00","created_by":"elh","updated_at":"2026-01-09T14:47:59.450372-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.4","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:47:59.453238-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.5","title":"WebSocket play-interface.js (streaming UI)","design":"Files: META-INF/resources/play-interface.js, templates/Story/play.html","acceptance_criteria":"UI streams assistant tokens; final message renders HTML from server; reconnect re-requests history","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:48:08.150006-05:00","created_by":"elh","updated_at":"2026-01-09T14:48:08.150006-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.5","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:48:08.153223-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.6","title":"Memory compaction hook -\u003e StoryEvent creation","design":"Files: ChatMemoryCompactedEvent.java, ChatMemoryCompactionListener.java","acceptance_criteria":"When memory window drops messages, a StoryEvent is created (tags: memory/summary)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:48:14.453611-05:00","created_by":"elh","updated_at":"2026-01-09T14:48:14.453611-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.6","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:48:14.456637-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.7","title":"Neo4jChatMemoryStore (persist LangChain4j memory)","description":"## Goal\nPersist LangChain4j chat memory to Neo4j so conversations survive restarts.\n\n## Approach\nImplement `dev.langchain4j.store.memory.chat.ChatMemoryStore`:\n- Key: `storyThreadId`\n- Value: serialized message list (LangChain4j serializer/deserializer)\n\n## Acceptance\n- Memory persists across app restart for the same `storyThreadId`\n- Window size controlled via `quarkus.langchain4j.chat-memory.*` config\n\n## Data\n- Neo4j node like `(:ChatMemory {id, messagesJson, updatedAt})`\n","design":"Files: Neo4jChatMemoryStore.java; config in application.properties","acceptance_criteria":"ChatMemoryStore reads/writes messages keyed by storyThreadId; survives restart","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:57:39.607478-05:00","created_by":"elh","updated_at":"2026-01-09T14:58:03.945964-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.7","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:57:39.608181-05:00","created_by":"elh"}]}
