{"id":"quarkus-soloplay-qsu","title":"WebSocket streaming play + server-side memory","description":"## Goal\nReplace stateless `/api/story/play` request/response with a WebSocket-based streaming “Play” experience with server-side persisted conversation memory and history.\n\n## Current State\n- Backend: `PlayAgent` + `GameMasterService` invoked via `POST /api/story/play` (`dev.ebullient.soloplay.api.StoryResource#play`)\n- Frontend: `src/main/resources/META-INF/resources/play-interface.js` uses `fetch()` and stores history in `localStorage`\n- Memory: ephemeral (no persisted `ChatMemoryStore`)\n\n## Target State\n- WebSocket endpoint: `/ws/story/{storyThreadId}` streams tokens/events\n- Server-side conversation continuity via persisted `ChatMemoryStore` (Neo4j)\n- Server-side transcript/history so UI does not depend on `localStorage`\n- Memory compaction/eviction hook creates durable story artifacts (e.g., `StoryEvent` summaries)\n\n## Key Decisions\n- Memory key: `storyThreadId` (same as current `@MemoryId String storyThreadId`)\n- Streaming: LangChain4j `TokenStream` for partial deltas + final completion\n- Rendering: stream text; final message replaces placeholder with server-rendered HTML (CommonMark via `MarkdownAugmenter`)\n\n## Milestones\n1) WS protocol + endpoint skeleton\n2) `PlayAgent.chatStream(...)` + streaming orchestration service\n3) Persisted `ChatMemoryStore` in Neo4j (+ config)\n4) Transcript persistence + history_request\n5) Compaction hook -\u003e `StoryEvent` creation\n6) Switch play UI to WebSocket + reconnect/history\n\n## Risks / Notes\n- Concurrency: enforce 1 in-flight generation per WS connection; decide multi-tab behavior for same story thread.\n- Consider adding `io.quarkiverse.langchain4j:quarkus-langchain4j-websockets-next` later if we want WS-connection-based default memory IDs; not required if we keep `@MemoryId storyThreadId`.\nEOF`\n","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-09T14:46:37.592207-05:00","created_by":"elh","updated_at":"2026-01-09T15:00:53.062208-05:00"}
{"id":"quarkus-soloplay-qsu.1","title":"WS protocol + StoryPlayWebSocket skeleton","design":"## Goal\nCreate `/ws/story/{storyThreadId}` WebSocket endpoint for Play with a stable JSON protocol for streaming.\n\n## Protocol\nClient -\u003e Server (JSON):\n- `{\"type\":\"history_request\",\"limit\":100}`\n- `{\"type\":\"user_message\",\"id\":\"\u003cuuid\u003e\",\"text\":\"...\"}`\n- (optional) `{\"type\":\"cancel\",\"id\":\"\u003cuuid\u003e\"}`\n\nServer -\u003e Client (JSON):\n- `{\"type\":\"session\",\"storyThreadId\":\"...\",\"storyName\":\"...\"}`\n- `{\"type\":\"history\",\"messages\":[{\"role\":\"user|assistant\",\"markdown\":\"...\",\"html\":\"...\",\"ts\":\"...\"}]}`\n- `{\"type\":\"assistant_start\",\"id\":\"\u003cuuid\u003e\"}`\n- `{\"type\":\"assistant_delta\",\"id\":\"\u003cuuid\u003e\",\"text\":\"...\"}`\n- `{\"type\":\"assistant_done\",\"id\":\"\u003cuuid\u003e\",\"markdown\":\"...\",\"html\":\"...\"}`\n- `{\"type\":\"error\",\"id\":\"\u003cuuid\u003e\",\"message\":\"...\"}`\n\n## Acceptance\n- Connection open sends `session` (or `error` if story thread missing)\n- Sending `user_message` yields `assistant_start` + one or more `assistant_delta` + `assistant_done`\n- Endpoint enforces 1 in-flight generation per connection (reject or queue)\n\n## Implementation Notes\n- New endpoint: `src/main/java/dev/ebullient/soloplay/api/StoryPlayWebSocket.java`\n- Message models: `src/main/java/dev/ebullient/soloplay/api/ws/PlayWsClientMessage.java`, `.../PlayWsServerMessage.java`\n","acceptance_criteria":"Client can connect to /ws/story/{id}; server sends session; user_message returns assistant_start/delta/done messages","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:46:55.752517-05:00","created_by":"elh","updated_at":"2026-01-09T15:02:24.933979-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.1","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:46:55.755475-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.2","title":"Add PlayAgent TokenStream method","description":"## Goal\nAdd streaming API to `PlayAgent` using LangChain4j `TokenStream`, while keeping current non-streaming method for REST fallback.\n\n## Acceptance\n- `PlayAgent` exposes `TokenStream chatStream(...)` mirroring the existing parameter set (including `@MemoryId storyThreadId` and `@UserMessage`)\n- Existing `String chat(...)` remains unchanged and continues to back `POST /api/story/play`\n- Streaming emits partial deltas and final completion\n\n## Notes\n- Uses LangChain4j `dev.langchain4j.service.TokenStream`\n- Provider must support streaming (Ollama typically does; validate behavior with configured model)\n","design":"File: PlayAgent.java","acceptance_criteria":"PlayAgent exposes chatStream(...) returning TokenStream; existing chat(...) remains for REST fallback","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:47:06.358302-05:00","created_by":"elh","updated_at":"2026-01-09T15:02:52.879196-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.2","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:47:06.361185-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.3","title":"GameMasterStreamingService orchestration","description":"## Goal\nAdd a streaming orchestration service that loads story context and streams agent output to the WebSocket client.\n\n## Responsibilities\n- Load `StoryThread` (same logic as current `GameMasterService.chat`)\n- Call `PlayAgent.chatStream(...)`\n- Wire `TokenStream` callbacks:\n  - onPartialResponse -\u003e send `assistant_delta`\n  - onCompleteResponse -\u003e render markdown -\u003e HTML via `MarkdownAugmenter`, send `assistant_done`\n  - onError -\u003e send `error`\n- Update `StoryThread.lastPlayedAt` on successful completion\n\n## Acceptance\n- WS responses include HTML in `assistant_done` and deltas in `assistant_delta`\n- `lastPlayedAt` updates once per completed assistant response\n- Errors don’t kill the WS connection (unless unrecoverable)\n\n## Files\n- `src/main/java/dev/ebullient/soloplay/ai/GameMasterStreamingService.java` (new)","design":"Files: GameMasterStreamingService.java, reuse MarkdownAugmenter","acceptance_criteria":"Loads StoryThread; streams deltas to WS; updates lastPlayedAt on completion; handles errors","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:47:44.132219-05:00","created_by":"elh","updated_at":"2026-01-09T15:03:12.087177-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.3","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:47:44.135333-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.4","title":"Transcript persistence + history_request","description":"## Goal\nPersist full conversation transcript in Neo4j for UI history, independent of the chat memory window, and support `history_request`.\n\n## Rationale\nLangChain4j chat memory is a bounded window for prompting, not a durable user-facing chat log. UI history should come from a separate store.\n\n## Data Model\nAppend-only message nodes, keyed by story thread:\n- `storyThreadId`, `role` (user/assistant), `markdown`, `html`, `ts`, `seq` (monotonic per thread)\n\n## API\n- WS `history_request {limit}` returns `history` message with last N transcript entries (ordered oldest-\u003enewest)\n- (optional later) REST `GET /api/story/{slug}/history?limit=N`\n\n## Acceptance\n- Refreshing browser loads prior messages from server transcript (no localStorage required)\n- Transcript is written for both user messages and assistant final responses\n\n## Files\n- `src/main/java/dev/ebullient/soloplay/data/ConversationMessage.java` (new)\n- Repository methods (new class or extend `StoryRepository`)","design":"Files: ConversationMessage.java + repository changes","acceptance_criteria":"Server can send last N turns from Neo4j transcript; UI no longer depends on localStorage","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:47:59.450372-05:00","created_by":"elh","updated_at":"2026-01-09T15:03:29.274799-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.4","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:47:59.453238-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.5","title":"WebSocket play-interface.js (streaming UI)","description":"## Goal\nReplace fetch/localStorage chat UI with a WebSocket streaming client.\n\n## Behavior\n- Open WS to `/ws/story/{storyThreadId}`\n- On open: send `history_request`\n- On send:\n  - append user message immediately\n  - create assistant placeholder bubble\n  - disable input until `assistant_done` (or implement queueing)\n- On `assistant_delta`: append streamed text to placeholder using `textContent`\n- On `assistant_done`: replace placeholder content with server-provided `html`\n- Reconnect with backoff; on reconnect re-request history\n\n## Acceptance\n- Tokens stream into UI without waiting for full completion\n- Reload shows history from server transcript\n- localStorage usage removed for play history\n\n## Files\n- `src/main/resources/META-INF/resources/play-interface.js`\n- `src/main/resources/templates/Story/play.html` (script wiring, optional connection indicator)","design":"Files: META-INF/resources/play-interface.js, templates/Story/play.html","acceptance_criteria":"UI streams assistant tokens; final message renders HTML from server; reconnect re-requests history","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:48:08.150006-05:00","created_by":"elh","updated_at":"2026-01-09T15:03:46.03709-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.5","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:48:08.153223-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.6","title":"Memory compaction hook -\u003e StoryEvent creation","description":"## Goal\nWhen chat memory window overflows and older messages are dropped, create durable story artifacts so important events aren’t lost.\n\n## Approach\n- Detect compaction in `ChatMemoryStore.updateMessages(memoryId, newMessages)` by comparing stored previous list with new list\n- If messages were dropped, publish a CDI event `ChatMemoryCompacted(storyThreadId, droppedMessages)`\n- Listener creates a `StoryEvent`:\n  - MVP: store raw dropped text (or a truncated excerpt) as an event with tags like `memory,summary`\n  - Better: run a summarizer LLM call over dropped messages and store a compact “story so far” summary\n\n## Acceptance\n- When memory window drops messages, at least one `StoryEvent` is created for that story thread\n- Events tagged to allow later retrieval (e.g., `memory`, `summary`)\n\n## Files\n- `src/main/java/dev/ebullient/soloplay/ai/memory/ChatMemoryCompactedEvent.java`\n- `src/main/java/dev/ebullient/soloplay/ai/memory/ChatMemoryCompactionListener.java`","design":"Files: ChatMemoryCompactedEvent.java, ChatMemoryCompactionListener.java","acceptance_criteria":"When memory window drops messages, a StoryEvent is created (tags: memory/summary)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:48:14.453611-05:00","created_by":"elh","updated_at":"2026-01-09T15:04:06.456055-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.6","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:48:14.456637-05:00","created_by":"elh"}]}
{"id":"quarkus-soloplay-qsu.7","title":"Neo4jChatMemoryStore (persist LangChain4j memory)","description":"## Goal\nPersist LangChain4j chat memory to Neo4j so conversation continuity survives restarts.\n\n## Implementation\nImplement `dev.langchain4j.store.memory.chat.ChatMemoryStore`:\n- Key: `storyThreadId` (Object from `@MemoryId`)\n- Stored value: serialized `List\u003cChatMessage\u003e` using LangChain4j serializer/deserializer\n- Node shape (simple):\n  - `(:ChatMemory {id: \u003cstoryThreadId\u003e, messagesJson: \"...\", updatedAt: ...})`\n\n## Configuration\n- Use Quarkus LangChain4j default memory provider with MESSAGE_WINDOW:\n  - `quarkus.langchain4j.chat-memory.type=MESSAGE_WINDOW`\n  - `quarkus.langchain4j.chat-memory.memory-window.max-messages=80`\n\n## Acceptance\n- For the same `storyThreadId`, memory persists across app restart\n- Memory window respects configured max-messages\n- (If implementing compaction detection here) emits compaction event when messages are dropped\n\n## Files\n- `src/main/java/dev/ebullient/soloplay/ai/memory/Neo4jChatMemoryStore.java`\n- `src/main/resources/application.properties`\n- `src/main/resources/neo4j-indexes.cypher` (optional index/constraint for ChatMemory.id)","design":"Files: Neo4jChatMemoryStore.java; config in application.properties","acceptance_criteria":"ChatMemoryStore reads/writes messages keyed by storyThreadId; survives restart","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-09T14:57:39.607478-05:00","created_by":"elh","updated_at":"2026-01-09T15:12:28.684901-05:00","dependencies":[{"issue_id":"quarkus-soloplay-qsu.7","depends_on_id":"quarkus-soloplay-qsu","type":"parent-child","created_at":"2026-01-09T14:57:39.608181-05:00","created_by":"elh"}]}
